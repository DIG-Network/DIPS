# DIP-0003: Proof of Content Presence

Authors: Michael Taylor

## Abstract

This proposal introduces a "Proof of Content Presence" mechanism to verify that content served through DIG Network mirrors originates directly from the claimed mirror server rather than through proxies or intermediaries. This enhancement aims to prevent reward gaming through proxy servers and ensure that rewards are distributed only to legitimate mirrors actively replicating and serving content.

## Motivation

The current DIG Network validation system relies on Proofs of Inclusion to verify that served content belongs to the correct datastore. However, this mechanism alone cannot prevent malicious actors from placing proxies in front of legitimate mirrors to intercept requests and claim rewards without actually replicating or serving the data themselves. This creates an economic vulnerability where rewards may be diverted from genuine infrastructure providers to proxy operators.

## Specification

### Validator Coin Discovery

Validator coins are created with a deterministic hint based on the store ID they validate. This enables DIG Nodes to easily discover relevant validators for any store they wish to mirror:

```typescript
interface ValidatorCoinMemo {
  publicKey: string;    // Validator's public key
  host: string;         // Validator's host for nonce retrieval
}

function createValidatorHint(storeId: Buffer, epochNumber: number): Buffer {
  // Ensure storeId is 32-byte buffer
  if (!Buffer.isBuffer(storeId) || storeId.length !== 32) {
    throw new Error("Invalid input. Must be a 32-byte buffer.");
  }

  // Create seed incorporating epoch
  const seed = `validator-epoch${epochNumber}`;
  
  // Combine seed and store ID
  const combinedBuffer = Buffer.concat([
    Buffer.from(seed),
    storeId
  ]);

  // Hash to get 32-byte hint
  const hash = crypto.createHash("sha256");
  hash.update(combinedBuffer);
  return hash.digest();
}
```

### Server Coin Structure

DIG Nodes must create separate server coins for each validator they wish to receive rewards from. Each server coin's memo contains:


```typescript
interface ServerCoinMemo {
  host: string;              // Mirror's location (IPv4, IPv6, or hostname)
  publicKey: string;         // Mirror's public key for signing responses
  validatorPublicKey: string;// Public key of specific validator this coin is for
  proofOfOwnership: {
    hostSignature: string;   // Signature of the mirror's host
    validatorNonceSignature: string; // Signature of (host + validator nonce + epoch)
  }
}
```

### Server Coin Creation Process

1. DIG Node identifies validator coin on chain using store ID hint
2. Retrieves validator's public key and host from validator coin
3. Requests nonce from validator's host
4. Creates proof of ownership including:
   - Signature of own host
   - Signature of own public key
   - Signature of validator-provided nonce
5. Creates server coin with validator's public key and proof

### Validation Process

1. Validator only processes server coins that include its public key
2. Validates DIG Node's proof of ownership:
   - Verifies DIG Node's host signature
   - Verifies DIG Node's public key signature
   - Verifies nonce signature matches nonce provided
3. Ensures first-seen rule for DIG Node's public key for this store ID
4. Proceeds with content validation and reward distribution

This coupling between server coins and specific validators provides several benefits:
- Clear relationship between mirrors and validators
- Validator-specific proof of ownership
- Prevention of front-running public key registration through validator nonce
- Simple filtering of relevant server coins for validators
- Clean separation of responsibilities

### Challenge-Response Authentication

Before the main validation process begins, the validator performs a challenge-response test:

1. **CRITICAL**: Validator verifies this server coin is the first and only instance of this public key across all server coins for this store ID. Any other server coins with the same public key for this store ID are ignored, regardless of their host.
2. Validator generates a random message
3. Validator encrypts the message using the public key from the server coin
4. Validator sends the encrypted message to the host specified in the server coin (and ONLY to this host)
5. Mirror server must decrypt the message using its private key and return the original message
6. Validator verifies the returned message matches the original

This ensures the host has actual possession of the private key corresponding to the public key in the server coin and prevents proxy attacks by only communicating with the first registered host for each public key.

### Validation Process

#### 1. Server Coin Selection and First-Seen Validation
- Validator selects a server coin for the target datastore
- **CRITICAL**: Validator verifies this is the first and only instance of this public key across all server coins for this store ID. This is a foundational security requirement - any other server coins with the same public key for this store ID MUST be ignored.
- Extracts host, public key, and proof of ownership from memo field

#### 2. Content Request
- Validator generates a unique nonce/timestamp
- Sends HTTP request to host from server coin for random chunks of content including:
  - `X-DIG-Nonce` header with generated nonce
  - `Range` header specifying byte ranges for requested chunks
    - Uses standard HTTP Range header format: `Range: bytes=start-end`
    - Requests multiple random 100KB chunks across the content
    - Example: `Range: bytes=0-102399, 1048576-1150975`
  - Standard content request headers

#### 3. Mirror Response
- Mirror server must:
  - Generate signature using private key:
    - Sign(`content` + `nonce`)
  - Include signature in response header:
    - `X-DIG-Signature`: Base64(signature)
  - **CRITICAL**: Begin streaming content immediately
    - Must not wait to load full content before starting stream
    - First byte latency is monitored as key indicator
    - Delay in initial response suggests content is being proxied
    - Any significant delay may result in validation failure
  - Serve requested content with proper streaming headers:
    - `Transfer-Encoding: chunked`
    - Appropriate content length if known

#### 4. Validation
- Validator verifies:
  - Response signature using public key from server coin
  - Content matches datastore expectations
  - **First byte latency** is within acceptable threshold
    - Immediate streaming indicates content is served from origin
    - Delayed first byte response suggests potential proxying
    - High latency may trigger validation failure
  - Response stream maintains consistent throughput
  - Host matches server coin
  - Public key is unique across network for this store ID

### Implementation Requirements

1. Mirror servers must maintain their private keys securely
2. Signatures must use ED25519 or similar approved algorithm
3. Nonce must be included in signature to prevent replay attacks
4. Response times must be measured and considered in validation
5. Host verification must handle DNS resolution appropriately

## Advantages

1. **Immediate Response Capability**: Legitimate mirrors can sign and serve content instantly, while proxies must first fetch content.

2. **Key Uniqueness Enforcement**: Requiring unique public keys per host prevents a single server from masquerading as multiple mirrors.

3. **Cryptographic Verification**: Strong cryptographic proof that the responding server possesses the private key registered in the server coin.

4. **Network Efficiency**: Helps ensure network resources are allocated to genuine infrastructure providers.

## Challenge-Response Attack Vectors

The challenge-response mechanism introduces some potential attack vectors that need to be considered:

1. **Pass-Through Proxy Attack**: A proxy could forward the encrypted challenge to the real mirror server, get the decrypted response, and pass it back to the validator. However, this introduces additional latency that might be detectable.

2. **First-Seen Rule**: Only the first server coin registered with a particular public key is considered valid. Any subsequent server coins using the same public key are ignored, regardless of their host value. This means:
   - If Server A (original mirror) registers a server coin with public key P and host H1
   - Then Server B (potential proxy) registers a server coin with the same public key P but host H2
   - Server B's coin is automatically ignored since that public key was already registered by Server A
   - Challenge-response requests are only ever sent to H1, the host of the first server coin
   
   This makes proxying significantly more difficult because:
   - A proxy cannot register a server coin with the same public key but different host
   - The validator only sends challenges to the original host
   - Even if a proxy intercepts traffic, it cannot receive the challenge directly from the validator

3. **Challenge Caching**: If the validator reuses challenges, a proxy could cache responses. This is mitigated by using unique random challenges each time.

4. **Timing Oracle Attacks**: The time taken to decrypt could potentially leak information about the private key, though this is generally impractical in this context.

## Attack Vectors and Protections

### Protected Attack Scenarios

1. **Direct Proxy Attack**
   - **Attack**: Attacker attempts to act as a reverse proxy to a legitimate mirror, forwarding requests and claiming rewards
   - **Protection**: Server coin public key validation ensures requests can only be served by the original registered host
   - **Why it Works**: Because validators only send requests to the host specified in the first server coin for a store ID's public key, proxy servers cannot intercept and claim rewards

2. **Real-time Download and Serve Attack**
   - **Attack**: Attacker attempts to download content on-demand from a legitimate mirror, sign it with their key, and serve it
   - **Protection**: First byte latency monitoring detects delays in content streaming
   - **Why it Works**: The additional time needed to download content before serving creates detectable latency that fails validation

3. **Virtual Mirror via Direct Proxies**
   - **Attack**: A mirror operator attempts to create multiple "virtual" mirrors by:
     - Setting up proxy servers with different hosts/IPs
     - Having proxies forward requests to a single backend server
     - Each proxy registers with its own public key
     - But only one copy of data is actually stored
   - **Protection**: Two layers of defense:
     1. **IP Address Uniqueness**:
        - Validator resolves all hostnames to IPs
        - Only first valid server coin per IP is accepted
        - Subsequent coins using same IP are rejected
        - Prevents multiple virtual servers on same machine
        - Makes subdomain-based attacks impossible
     2. **First Byte Latency Check**:
        - Even if using different IPs, proxying adds delay
        - Additional network hop causes detectable latency
        - Must maintain actual copies of data on each server
   - **Why it Works**: 
     - IP uniqueness forces physical server separation
     - Can't hide proxy latency even with different IPs
     - Economics force actual data replication across machines
     - Double protection: must have both unique IP and low latency

### Pre-cached Content and Network Benefits

1. **Acceptable Pre-caching**
   - **Scenario**: An operator downloads content from other mirrors ahead of time and stores it locally
   - **Status**: This is not only acceptable but beneficial to the network
   - **Why It's Good**:
     - They are maintaining a real copy of the data
     - They are adding redundancy to the network
     - They are improving geographic distribution
     - They can serve content with low latency
     - They are contributing to decentralization

2. **What We're Actually Preventing**
   - **Real-time Proxying**: Servers that simply forward requests without storing data
   - **Pass-through Proxies**: Systems that add latency without adding resilience
   - **Reward Stealing**: Attempts to claim rewards without providing infrastructure

3. **Network Philosophy**
   - The goal is data redundancy and availability
   - How a mirror initially acquires the data is less important than:
     - Actually storing the data
     - Serving it efficiently
     - Contributing to network resilience
     - Maintaining high availability

This aligns with the network's core mission of creating a robust, decentralized content delivery system.

## Limitations and Edge Cases

1. **Sophisticated Network Attacks**: Advanced BGP hijacking or DNS manipulation could potentially intercept traffic to legitimate hosts.

2. **Hardware Level Timing**: Extremely sophisticated setups might achieve latencies that make real-time proxying hard to detect.

3. **Network Latency Variations**: Geographic distance and network conditions can affect response times, making timing-based validation require careful tuning.

4. **Key Sharing**: Multiple physical servers could share the same key, though this violates protocol rules.

5. **Distributed Storage**: Edge cases around distributed storage systems need careful consideration for latency validation.

## Security Considerations

1. **Key Management**: 
   - Mirrors must securely store private keys
   - Each mirror must generate a unique key pair
   - First-seen rule for public keys must be strictly enforced
   - Private keys should never be shared between mirrors

2. **Host Verification**:
   - Validators must only send challenges to the host specified in the first server coin for each public key
   - Host resolution and connection must use secure DNS
   - IP address changes require new server coin registration with new key pair

3. **Nonce Requirements**: 
   - Ensure nonce provides sufficient entropy
   - Nonces must never be reused
3. **Timing Attacks**: Consider network variance in timing validation
4. **Replay Protection**: Implement strict nonce validation
5. **DDoS Mitigation**: Handle high volume of validation requests

## Backwards Compatibility

This proposal requires updates to:
- Mirror server implementations
- Validator software
- Server coin structure

Existing server coins will need to be reissued with the new memo field structure.

## Challenge-Response Implementation

```typescript
interface ChallengeRequest {
  encryptedMessage: Buffer;
  timestamp: number;
}

interface ChallengeResponse {
  decryptedMessage: Buffer;
  responseTime: number;
}

// Validator side
async function performChallengeResponse(
  host: string, 
  publicKey: Buffer
): Promise<boolean> {
  // Generate random challenge
  const originalMessage = crypto.randomBytes(32);
  
  // Encrypt with public key
  const encrypted = encryptWithPublicKey(originalMessage, publicKey);
  
  // Send to host and get response
  const response = await sendChallenge(host, encrypted);
  
  // Verify response matches original
  return Buffer.compare(response, originalMessage) === 0;
}

// Mirror server side
function handleChallenge(
  encrypted: Buffer, 
  privateKey: Buffer
): Buffer {
  // Decrypt challenge
  return decryptWithPrivateKey(encrypted, privateKey);
}
```

## Reference Implementation

```typescript
interface ServerCoin {
  host: string;
  publicKey: Buffer;
  proofOfOwnership: string;
}

interface Response {
  content: Buffer;
  headers: {
    'x-dig-signature'?: string;
  };
  request: {
    headers: {
      'x-dig-nonce'?: string;
    };
  };
  elapsedTime: number;
}

// Example signature generation (Mirror Server)
function generateSignature(
  content: Buffer, 
  nonce: string, 
  privateKey: Buffer
): string {
  const message = Buffer.concat([content, Buffer.from(nonce, 'utf-8')]);
  const signature = sign(message, privateKey);
  return signature.toString('base64');
}

// Example validation (Validator)
function validateResponse(
  response: Response, 
  serverCoin: ServerCoin
): boolean {
  const content = response.content;
  const signature = response.headers['x-dig-signature'];
  const nonce = response.request.headers['x-dig-nonce'];
  
  if (!signature || !nonce) {
    return false;
  }

  // Verify signature
  const message = Buffer.concat([content, Buffer.from(nonce, 'utf-8')]);
  const isValid = verify(
    Buffer.from(signature, 'base64'),
    message,
    serverCoin.publicKey
  );
  
  // Verify timing
  const isTimingValid = validateResponseTiming(response.elapsedTime);
  
  return isValid && isTimingValid;
}

// Challenge-Response Implementation
interface ChallengeResponse {
  success: boolean;
  error?: string;
}

// Validator side
async function performChallengeResponse(
  host: string, 
  publicKey: Buffer
): Promise<ChallengeResponse> {
  try {
    // Generate random challenge
    const originalMessage = crypto.randomBytes(32);
    
    // Encrypt with public key
    const encryptedMessage = encryptWithPublicKey(originalMessage, publicKey);
    
    // Send to host and get response
    const response = await sendChallenge(host, encryptedMessage);
    
    // Verify response matches original
    return {
      success: Buffer.compare(response, originalMessage) === 0
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

// Mirror server side
function handleChallenge(
  encryptedMessage: Buffer, 
  privateKey: Buffer
): Buffer {
  // Decrypt challenge
  return decryptWithPrivateKey(encryptedMessage, privateKey);
}

// Helper functions for timing validation
function validateResponseTiming(elapsedTime: number): boolean {
  const MAX_ACCEPTABLE_TIME = 500; // milliseconds
  return elapsedTime < MAX_ACCEPTABLE_TIME;
}

// Server coin validation
function isValidServerCoin(
  serverCoin: ServerCoin, 
  existingCoins: ServerCoin[]
): boolean {
  // Check if this public key has been seen before
  return !existingCoins.some(coin => 
    Buffer.compare(coin.publicKey, serverCoin.publicKey) === 0
  );
}
```

### Epoch-Based Server Coin Registration

Server coins must be recreated every epoch (7 days), which provides additional security benefits and considerations:

1. **Fresh Key Verification**
   - Each epoch requires a new server coin registration
   - Fresh proof of ownership must be generated
   - Validator provides new challenge nonce for each epoch
   - Previous epoch's proofs become invalid

2. **Front-Running Protection**
   - Attacker would need to front-run every epoch
   - Failed front-running attempt locks them out for entire epoch
   - Economic cost (staking requirement) for each attempt
   - Multiple failed attempts easily detectable

3. **Key Rotation Options**
   - Mirrors can optionally rotate keys each epoch
   - Same public key can be used across epochs if desired
   - First-seen rule applies within each epoch independently
   - Historical key usage can be tracked for reputation

4. **Implementation Considerations**
```typescript
interface EpochServerCoin extends ServerCoinMemo {
  epoch: number;         // Current epoch number
  epochStartTime: number;// Epoch start timestamp
  epochChallenge: string;// Epoch-specific validator challenge
}

function validateEpochServerCoin(
  coin: EpochServerCoin,
  currentEpoch: number
): boolean {
  // Ensure coin is for current epoch
  if (coin.epoch !== currentEpoch) {
    return false;
  }

  // Validate proof of ownership includes epoch challenge
  const proofValid = validateProof({
    publicKey: Buffer.from(coin.publicKey, 'base64'),
    host: coin.host,
    proofOfOwnership: coin.proofOfOwnership,
    challenge: coin.epochChallenge
  });

  // Check first-seen rule for this epoch
  const isFirstInEpoch = isFirstServerCoinForKeyInEpoch(
    coin.publicKey,
    coin.epoch
  );

  return proofValid && isFirstInEpoch;
}
```

5. **Epoch Transition Handling**
   - Mirrors should register new server coin before epoch end
   - Grace period could allow overlap for smooth transition
   - Old epoch coins remain valid until exact cutoff
   - New epoch coins can be pre-registered during grace period

This epoch-based registration system provides:
- Regular proof of continued operation
- Fresh challenge-response verification
- Multiple chances to prevent front-running
- Clear timeline for key rotation
- Clean slate for first-seen rule each epoch